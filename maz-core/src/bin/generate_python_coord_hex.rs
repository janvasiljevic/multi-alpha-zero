use game_hex::game_hex::{HexGame};
use maz_core::mapping::hex_canonical_mapper::{
    HexCanonicalMapper,
};
use std::path::Path;

fn main() {
    let hex_size = 5;
    let hex = HexGame::new(hex_size).unwrap();
    let canonical_hex_mapper = HexCanonicalMapper::new(&hex);

    let full_path = file!();
    let filename = Path::new(full_path).file_name().unwrap().to_str().unwrap();
    let array_name = format!("all_hex_{}_coords", hex_size);

    println!("import torch");
    println!("\n# This tensor was generated by {filename}");
    println!("{array_name} = torch.tensor([");

    for (_, &abs_coord) in canonical_hex_mapper.index_to_coord.iter().enumerate() {
        let q = abs_coord.q;
        let r = abs_coord.r;
        let s = abs_coord.s();

        println!("    [{}, {}, {}],", q, r, s);
    }

    println!("], dtype=torch.long)\n");

    let num_of_hexes = canonical_hex_mapper.num_of_hexes;

    println!(
        "assert {array_name}.shape == ({num_of_hexes}, 3), f'Expected shape ({num_of_hexes}, 3), but got {{{array_name}.shape}}'"
    );
    println!(
        "assert torch.all({array_name}.sum(dim=1) == 0).item(), 'Verification failed: Not all q+r+s sums equal 0'"
    );
}
